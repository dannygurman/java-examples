package concurrency.executors.and.future.ex2;

import java.util.concurrent.*;

//ExecutorService extends Executor

//Choose between ExecutorService's submit and ExecutorService's execute:

//There is a difference concerning exception/error handling.

//A task queued with execute() that generates some Throwable will cause the UncaughtExceptionHandler for the Thread running
// the task to be invoked.

// The default UncaughtExceptionHandler, which typically prints the Throwable stack trace to System.err, will be invoked if
// no custom handler has been installed.


//On the other hand, a Throwable generated by a task queued with submit() will bind the Throwable
// to the Future that was produced from the call to submit().
//
// Calling get() on that Future will throw an ExecutionException with the original Throwable as its cause (accessible by calling getCause() on the ExecutionException).
public class FutureExample1 {

    public void testFuture1() {


        //Using fixed thread pool
        int numOfThread = 10;
        ExecutorService executor = Executors.newFixedThreadPool(numOfThread);

        //Running
       // executor.execute( runnable ); //Return void
        Callable <String> callable = ()->  "Hello World";
        Future<String> future =  executor.submit( callable);//Return future

        // some operations
        try {
            String result = future.get();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

}
